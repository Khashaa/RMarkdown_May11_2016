---
title: "Creating Dynamic Documents with RMarkdown and Knitr"
author: "Marian L. Schmidt"
date: "May 11th, 2016"
output:
  html_document:
    code_folding: show
    highlight: kate
    keep_md: yes
    number_sections: yes
    smooth_scroll: yes
    theme: readable
    toc: yes
    toc_float:
      collapsed: no
      toc_depth: 3
---

```{r set-global-options, echo = FALSE}
knitr::opts_chunk$set(eval = TRUE, 
                      echo = TRUE, 
                      cache = TRUE,
                      include = TRUE,
                      collapse = FALSE,
                      dependson = NULL,
                      engine = "R", # Chunks will always have R code, unless noted
                      error = TRUE,
                      fig.path="Figures/",  # Set the figure options
                      fig.align = "center", 
                      fig.width = 7,
                      fig.height = 7)
```



```{r silent-packages, echo = FALSE, eval = TRUE, message=FALSE, include = FALSE}
library(knitr)
library(dplyr)
library(ggplot2)
library(DT)
library(plotly)
```




******************************************************************************************

# Welcome!

Information that is Relevant to this Tutorial  

This tutorial was constructed as a part of Dr. C Titus Brown's <a href="http://dib-training.readthedocs.io/en/pub/index.html" target="_blank">Data Intensive Biology (DIB)</a> training program at the University of California, Davis.  The DIB training program is hosting several local+remote workshops.

Today, there is are two remote classrooms tuning in:  

1. University of California, Davis  
2. Simon Fraser University in British Columbia, Canada.  

In addition, the audio of this tutorial and the screen of the main instructor will be shared on YouTube.

The Github repository for this website can <a href="https://github.com/marschmi/RMarkdown_May11_2016" target="_blank">be found here</a>.  



******************************************************************************************

# Amazing Resources

I could __not__ have made this tutorial without these amazing resources:  

1. The <a href="http://rmarkdown.rstudio.com/index.html" target="_blank">RMarkdown</a>.
 website hosted by RStudio.  
2. Dr. Yuhui Xie's book:  <a href="http://www.amazon.com/Dynamic-Documents-knitr-Chapman-Hall/dp/1482203537" target="_blank">Dynamic Documents with R and Knitr</a> 2^nd^ Edition.  
3. Dr. Karl Broman's <a href="http://kbroman.org/knitr_knutshell/" target="_blank">"Knitr in a Knutshell"</a>.  
4. <a href="https://www.rstudio.com/resources/cheatsheets/" target="_blank">Cheatsheets</a> released by RStudio.


******************************************************************************************

# Dynamic Documents  

<a href="https://en.wikipedia.org/wiki/Literate_programming">Literate programming</a> is the basic idea behind dynamic documents and was proposed by Donald Knuth in 1984.  Originally, it was for mixing the source code and documentation of software development together.  

The 3 steps of **Literate Programming**:  

1. **Parse** the source document and separate code from narratives.  
2. **Execute** source code and return results.  
3. **Mix** results from the source code with the original narratives.  


So that leaves 2 steps for us:  

Write:  
1. Analysis code  
2. A narrative to explain the results from the analysis code.  

Traditionally, people use comments in their code 

```{r mtcars-example-code, eval = FALSE, echo = TRUE}
# What does the data look like?
datatable(mtcars) # Interactive table 

# Is there a relationship between the weight of a car and the miles per gallon?
lm_mpg <- lm(mpg ~ wt, data = mtcars) # Run linear model predicting mpg based on wt
coef_lm_mpg <- coef(summary(lm_mpg)) # Extract coefficients to table 
kable(coef_lm_mpg) # Produce non-interactive table - function in knitr

# Plot the relationship between weight and miles per gallon  
plot <- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point() + # 
  geom_smooth(method = "lm") + theme_bw() + # add linear model and make black and white
  xlab("Weight (1000lbs)") + ylab("Miles per Gallon") # Add axis labels
ggplotly(plot) # Make the plot interactive
```


And if we evaluated the code?  
```{r mtcars-show, fig.height=4.5, fig.width=4.5, cache = FALSE}
# What does the data look like?
datatable(mtcars) # Interactive table 

# Is there a relationship between the weight of a car and the miles per gallon?
lm_mpg <- lm(mpg ~ wt, data = mtcars) # Run linear model predicting mpg based on wt
coef_lm_mpg <- coef(summary(lm_mpg)) # Extract coefficients to table 
kable(coef_lm_mpg) # Produce non-interactive table - function in knitr

# Plot the relationship between weight and miles per gallon  
plot <- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point() + # 
  geom_smooth(method = "lm") + theme_bw() + # add linear model and make black and white
  xlab("Weight (1000lbs)") + ylab("Miles per Gallon") # Add axis labels
ggplotly(plot) # Make the plot interactive
```



Then we could:  

1. **Tangle**:  Extract the source code out of the document.  
2. **Weave**:  Execute the code to get the compiled results.  

In dynamic documents, program or analysis code is run to produce output (e.g. tables, plots, models, etc) and then are explained through narrative writing. 


## Reproducible Research  

Reproducible research is one possible product of dynamic documents, however, it is not guaranteed!  Good practices for reproducible research include:  

1. Mange all source files under the same directory.  
2. Use relative paths.  
3. Do not change the work


******************************************************************************************

# Markdown

To fully understand RMarkdown, we first need to cover <a href="https://daringfireball.net/projects/markdown/">Markdown</a>, which is a system for writing simple, readable text that is easily converted to html.  Markdown essentially is two things:  

1. A plain text formatting syntax  
2. A software tool written in Perl.  
    - Converts the plain text formatting into HTML.  
    
>**Main goal of Markdown:**  
> Make the syntax of the raw (pre-html) document as readable possible. 

Would you rather read this?  
```html
<body>
  <section>
    <h1>Rock Climbing Packing List</h1>
    <ul>
      <li>Climbing Shoes</li>
      <li>Harness</li>
      <li>Backpack</li>
      <li>Rope</li>
      <li>Belayer</li>
    </ul>
  </section>
</body>
```
The above code is html.

Or this?  
```markdown
# Rock Climbing Packing List

* Climbing Shoes
* Harness
* Backpack  
* Rope
* Belayer
```
The above code is Markdown and it is clear that this option is definitely much easier to read!

We will talk more about the syntax of Markdown after we introduce RMarkdown. 

******************************************************************************************

# RMarkdown
<a href="http://rmarkdown.rstudio.com/">RMarkdown</a> is a variant of Markdown that makes it easy to create dynamic documents, presentations and reports from R.  It has embedded R code chunks to be used with `knitr` to make it easy to create reproducible (web-based) reports in the sense that they can be automatically regnerated when the underlying code it modified.    

- RMarkdown lets you combine **Markdown** with images, links, tables, LaTeX, and actual R code.
- **RStudio makes creating documents from RMarkdown easy** but you can use Pandoc (more on that later) instead.
- RStudio (like R) is free and runs on any operating system.


RMarkdown renders many different types of files including:  

- <a href="http://rmarkdown.rstudio.com/html_document_format.html">HTML</a>    
- <a href="http://rmarkdown.rstudio.com/pdf_document_format.html">PDF</a>  
- Markdown  
- <a href="http://rmarkdown.rstudio.com/word_document_format.html">Microsoft Word</a>   
- Presentations:  
    - Fancy HTML5 presentations:  
        - <a href="http://rmarkdown.rstudio.com/ioslides_presentation_format.html">ioslides</a>
        - <a href="http://rmarkdown.rstudio.com/slidy_presentation_format.html">Slidy</a>  
        - <a href="http://slidify.org/index.html">Slidify</a>
    - PDF Presentations:  
        - <a href="http://rmarkdown.rstudio.com/beamer_presentation_format.html">Beamer</a>  
    - Handouts:  
        - <a href="http://rmarkdown.rstudio.com/tufte_handout_format.html">Tufte Handouts</a> 
- <a href="http://rmarkdown.rstudio.com/package_vignette_format.html">HTML R Package Vignettes</a>  
- <a href="http://rmarkdown.rstudio.com/rmarkdown_websites.html">Even Entire Websites!</a>   

![](Images/Rmd_output.png)

While there are a lot of different types of rendered documents in RMarkdown, today we will focus primarily on HTML output files, as I have found these files to be the most useful and flexible for my research.

## Why R Markdown?
A convenient tool for reproducible and dynamic reports with R!       

- Execute R code in a few ways:  
    1. **Code chunks** 
    2. **Inline code**  
- Easy to:  
    - Embed images.  
    - Learn Markdown syntax.  
    - Include LaTeX equations.  
    - Include interactive tables.
    - Use version control with **Git**.  
        - Even easier to share and collaborate on analyses, projects and publications!
    - Add external links - Rmarkdown even understands html code!  
    - Make beautifully formatted documents.
- Do not need to worry about page breaks or figure placement.  
- Consolidate your code and write up into a single file:  
    + Slideshows, pdfs, html documents, word files  

## Simple Workflow  

To make a report:  

1. Create a `.Rmd` file.  
    - Create a YAML header (more on this in a minute!)
2. Write the content with RMarkdown syntax.  
3. Embed the R code in code chunks or inline code.  
4. Render the document output.  

![Workflow for creating a report](Images/rmd_workflow_cheatsheet.png)



**Overview of the steps RMarkdown takes to get to the rendered document:**  

1. Create `.Rmd` report that includes R code chunks and and markdown narratives (as indicated in steps above.).  
2. Give the `.Rmd` file to `knitr` to execute the R code chunks and create a new `.md` file.  
    - <a href="http://yihui.name/knitr/" target="_blank">Knitr</a> is a package within R that allows the integration of R code into rendered RMarkdown documents such as HTML, latex, pdf, word, among other document types.  
3. Give the `.md` file to **pandoc**, which will create the final rendered document (e.g. html, microsoft word, pdf, etc.).  
    - <a href="http://pandoc.org/" target="_blank">Pandoc</a> is a universal document converter and enables the conversion of one document type (in this case: `.Rmd`) to another (in this case: HTML)

![How an Rmd document is rendered](Images/Rmd_workflow.png)

While this may seem complicated, we can hit the "Knit" button at the top of the page like this:  
![](Images/knit_button.png)

or we can run the following code:  
```
rmarkdown::render("RMarkdown_Lesson.Rmd", "html_document")
```

## Creating a `.Rmd` File  

1.  In the menu bar, click **File -> New File -> RMarkdown**  
    - Or simply click on the green plus sign in the top left corner of RStudio.
![](Images/create_rmd.png)
2. The window below will pop up.  
- Inside of this window, choose the type of output by selecting the radio buttons.  **Note:** this output can be easily changed later!  
3. Click **OK**  
![](Images/new_rmd_yaml.png)  


## YAML Headers

YAML stands for "YAML Ain't Markup Language" or "Yet Another Markup Languge" and is basically a nested list structure that includes the metadata of the document.  It is enclosed between two lines of three dashes --- and as we saw above is automatically written by RStudio.  A simple example:  

```
---
title:  "Analysis Report"  
Author:  "Marian L. Schmidt"  
date: "May 2016"  
output:  html_document
---
```

The above example will create an HTML document.  However, the following options are also available.  

- `html_document`  
- `pdf_document`  
- `word_document`  
- `beamer_presentation` (pdf slideshow)  
- `ioslides_presentation` (HTML slideshow)  
- and more...  

Today, we will be focused on HTML files.  However, please be welcome to play around with creating word and pdf documents.  Presentation slides take on a slightly different syntax (e.g. to specify when one slide ends and the next one starts) and so there is a bit of markdown syntax specific to presentations that are beyond the focus of todays workshop.  



## Markdown Basics  

Check out the <a href="http://www.rstudio.com/wp-content/uploads/2015/03/rmarkdown-reference.pdf">RMarkdown Reference Guide</a>

Create lists with `+`, `-`, or `*`.



**Something to remember:**  End a line with two spaces to start a new paragraph!

> Time to think!  
> What happens when you run the following code?

```
*honey* is **very** _sweet_. Yum^!!!^  
**bold** and __bolder__  
R^2^ values are the **informative**!    
$R^{2}$ describe the *variance* explained in the model. W   
~~today is not my day~~  
[link](www.rstudio.com)  
# RMarkdown is the best  
## R is the best  
### Knitr is the best  
#### Pandoc is the best  
##### You're the best  
$$\sqrt{b^2 - 4ac}$$  
$X_{i,j}$  
> Today is Monday, May 11th  

### Chocolate Chip cookie Recipe 

- butter
- sugar  
    - A mix of brown & white sugar makes it more delicious
        - mix with butter before you add the *eggs*
- eggs 
- vanilla  
- Mix dry ingredients: 
    - flour, salt, baking soda  
- chocolate chips  
```


**Fun Fact!**  The table of contents of this website was created from headers with 1-3 pound symbols!



## Embed Code

There are 2 ways to embed code within an RMarkdown document.  

1. **Inline Code:**  Surround code with back ticks and r and then R will replace the inline code with the results of the code.  
    - For example:  
        - Two times five equals `r 2*5`  
        - ```Two times five equals "`r 2*5`" ```
2. **Code Chunks:**  



### R Code Chunks  

R code chunks can be used to render R output into documents or to display code for illustration.  

**The Anatomy of a knitr code chunk:**  

To insert an R code chunk, you can type it manually or just press the `Insert a new code chunk` button or use the shortcut key. This will produce the following code chunk:

![Inserting a code chunk](Images/insert_code_chunk.png)  

> ```{r chunk_name}

> ```


    ```{r}

    ```

Pressing tab when inside the braces will bring up code chunk options.

The following R code chunk labelled `basic-console` is as follows:

    ```{r }
    x <- 1:10
    y <- round(rnorm(10, x, 1), 2)
    df <- data.frame(x, y)
    df
    ```
    
The code chunk input and output is then displayed as follows:

```{r basicconsole}
x <- 1:10
y <- round(rnorm(10, x, 1), 2)
df <- data.frame(x, y)
df
```





### Global Chunk Options  

You may wish to have the same chunk settings throughout your document and so it might be nice to type options once instead of always re-typing it for each chunk.  To do so, you can set global chunk options at the top of the document.  

```
knitr::opts_chunk$set(echo = FALSE, 
                      eval = TRUE, 
                      message = FALSE,
                      warning = FALSE, 
                      fig.path = "Figures/",
                      fig.width = 12, 
                      fig.height = 8)
```

For example, if you're working with a collaborator who does not want to see the code - you could set `eval = TRUE` and `echo = FALSE` so the code is evaluated but not shown.  In addition, you may want to use `message = FALSE` and `warning = FALSE` so your collaborator does not see any messages or warnings from R.  

If you would like to save and store figures within a subdirectory within the project, `fig.path = "Figures/"`.  Here, the `"Figures/"` denotes a folder named *Figures* within the current directory where the figures produced within the document will be stored.  **Note:** by default figures are not saved.  

Global chunk options will be set for the rest of the document.  If you would like to have a particular chunk be different from the global options, specify at the beginning of that particular chunk.

Best practices regarding code chunks:  

- Always name/label your code chunks!  
    - When naming the code chunk:  Use `-` or `_` in between words for code chunks labels instead of spaces.  This will help you and other users of your document to navigate through.  
- Instead of specifying the chunk options in every chunk, set the global chunk options at the beginning of the document with `knitr::opts_chunk$set()`.  

Chunk labels must be unique throughout the document - otherwise there will be an error!



### Inline R Code  




**************************************************************************************************

## Installation

#### Load Packages 
The following packages are necessary for today's workshop.
```{r load-packages, echo = TRUE, eval = TRUE}
#install.packges("knitr")
library(knitr)
#install.packages("dplyr")
library(dplyr)
#install.packages("ggplot2")
library(ggplot2)
```


```{r setup, echo = TRUE, eval = TRUE}
knitr::opts_chunk$set(echo = TRUE, eval = TRUE)
```





## Rendering Output  



## Output Options 




## Embedding Equations with LaTeX  

Thank you to   
<a href="http://www.statpower.net/Content/310/R%20Stuff/SampleMarkdown.html">James H. Steiger</a> for this awesome website.

What's the difference between these two lines of code? 

```
$$X_{i,j}$$
$X_{i,j}$
```



## RMarkdown Appearance and Syle
RMarkdown has several options that control the appearance of HTML documents.  Some arguments to choose from are:  

- **theme**  
- **highlight**  
- **smart**  


The HTML output themes are drawn from the <a href="http://bootswatch.com/">Bootswatch</a> library.  Valid **HTML themes** include the following:    

- `cerulean`, `cosmo`,`flatly`, `journal`, `readable`,`spacelab`, and `united`.  
    - For example, the theme of this page is `readable`.
- Pass null for no theme (in this case you can use the css parameter to add your own styles).

**Highlight** specifies the syntax highlighting style. Supported styles include the following:  

- `default`, `espresso`, `haddock`, `kate`, `monochrome`, `pygments`, `tango`, `textmate`, and `zenburn`.   
- Pass null to prevent syntax highlighting.

**Smart** indicates whether to produce typographically correct output, converting straight quotes to curly quotes, --- to em-dashes, -- to en-dashes, and ... to ellipses. **Smart** is enabled by default.

For example:

```
---
output:
  html_document:
    theme: slate
    highlight: tango
---
```

If you felt inclined, you could also produce and use your own theme.  If you did so, the output section of your YAML header would like like:  
```
output:
  html_document:
    css: styles.css
```

If you wanted to go the extra mile and write your own theme in addition to highlight, the YAML header would look like: 
```
---
output:
  html_document:
    theme: null
    highlight: null
    css: styles.css
---
```



Here's a link to learn more about the <a href="http://rmarkdown.rstudio.com/html_document_format.html#appearance_and_style">Appearance and Style</a> in HTML output.




**************************************************************************************************

# Knitr  



Knitr:  

1. **Identifies code** including chunks and inline
2. **Evaluates** all the code and returns the results 
3. **Renders** a formatted results and combines with original file.   


Mainly **Knitr** works with code chunks and inline code.

A code chunk looks like:

    ```{r simulate_data}  
    x <- rnorm(100)  
    y <- 2*x + rnorm(100)
    ```
  

## Chunk Options  

Use R code to say whether or not to evaluate a chunk (so cool!).  


## Global Chunk Options

## Chunk Labels 

## Chunk Syntax 


## Collapse Output (p. 51)


## Spell Check  

Spelling may not be our strong suit and as a result, we may need to check the spelling in our document.  There are two ways to check the spelling:  

1. Click on the "ABC checkmark" to the left of the magnifying glass button in RStudio.  ![](Images/Rmd_output.png)  
2. Use the `aspell()` function from the `utils` package.  However, it would be desirable to skip code chunks.  The `aspell()` function can take a filter function to skip certain lines in the files and can be used with the function `knit_filter()` which was designed to skip over code chunks in a file.  


## Knitr Themes
The knitr syntax theme can be adjusted or completely customized.  If you do not prefer the default themes, use the object `knit_theme` to change it.  There are **80 themes** contained within `knitr` and we can view the names of them by `knit_theme$get()`.

What are the first 30 `knitr` themes?

```{r knitr-themes}
head(knit_theme$get(), 30)
```

We can use `knit_theme$set()` to set the theme.  For example, to set the theme to *fruit* we could run the following code:

```{r knitr-fruit-theme}
knit_theme$set("fruit")
```

Here's the link to find your favorite theme of all the <a href="http://animation.r-forge.r-project.org/knitr/">80 knitr highlight themes</a>.


## Other Programming Languages  

While knitr must be run within the R environment, it also supports many other programming languages including:  

- Python  
- Ruby  
- Haskell  
- awk/gawk  
- sed  
- shell scripts  
- Perl  
- SAS  
- TikZ  
- Graphviz  
- C++  
- And others...  

However, we have to install the corresponding software package in advance to use an engine.    

Enter the  `engine` function in Knitr.  This function allows the user to specify the language for a chunk.  

- `engine = "bash"` will load in bash and allow the user to write shell scripts within that code chunk.  




# Caching  

**Problem:**  Some code chunks take a *long* time to run and may not be updated very often.  

**Solution:**  Caching!  If a code chunk has not been modified since the last rendering of the document, the old results will be directly used instead of re-running the chunk.


**Very simple solution:**  Exit knitting early -> if the rest of the document does not need to be rendered, simply put the `knit_exit()` and the rest of the document will be ignored.  Therefore, results from all previous text and code chunks will be returned.


**lazy-loading** is when an aobject will not be loaded into memory until it is used.  A "promise" is instead created, which is computationally easy (to learn more run`?promise`).


Therefore, when rendering the document, cached chunks are skipped and the output created previously from these chunks are will be (lazy-) loaded from the `cache` folder.

However, if a single change to the chunk occurs (even a whitespace counts!) then `knitr` will acknowledge this change and will actually run the chunk when the document is rendered.


`cache`=TRUE, default =FALSE

`cache.path`



Some issues with caching:  

1. R is updated every few months.  `R.version.string`  
2. External files that knitr does not track changes, may be updated and results will need to be re-run.  
3. Somtimes a cached chunk might rely on objects from other cached chunk.  This can be a serious problem!  Hence, chunk dependencies!  

`dependson` chunk option in knitr.  

## Chunk Dependencies    

### Manual Dependency  

- `dependson` specifies which other chunks the current chunk relies on by setting a vector of chunk labels.  
    - Examples with integers:  
        - `depesndson = 1`: Chunk relies on first Chunk  
        - `dependson = c(6,8)`:  Chunk relies on 6^th^ and 8^th^ chunks  
        - `dependson = -1`:  Chunk relies on previous chunk.
        - `dependson = c(-1, -2)`: Chunk relies on the two previous chunks.  
        - **Note:**  When `dependson` takes on an integer value, it cannot make a chunk depend on *later* chunks - only *previous* chunks.  Therefore, it may be useful to use the chunk names or vectors of chunk names.  
    - Examples with chunk names:  
        - `dependson = c("Chunk-1", "Chunk-2", "Chunk-3")`  
        - `dependson = c("data-generation", "data-transforamtion")`  
- As a result, each time one of the cached chunks `"Chunk-1"`, `"Chunk-2"`, and `"Chunk-3"` are re-built, the current chunk will lose its cache and also be rebuilt!  

### Automatic Dependency  

Enter:  `autodep` chunk option and function `dep_auto()`  

- `autodep` and `dep_auto()` state that if any objects in the current chunk are created in previous chunks, then the current chunk depends on a previous chunk.  

For a more conservative approach, enter `dep_prev()`.

- `dep_prev` states that a cached chunk will depend on all of its previous chunks.  Therefore, whenever previous chunks are updated, all the later chunks will also be updated.  


Knitr only tracks changes with cached chunks, **not in uncached chunks!**  Fortunately, knitr will give a warning when it sees a dependency on an uncached chunk.  

### Load Cache Manually  

Suppose you calculated a value *z* in a chunk towards the end of the document, however, you would like to use *z* in an earlier chunk.  However, this impossible because knitr compiles the document in a linear fashion and it cannot use objects created in the future.  

Enter:  `load_cache`, which takes a chunk label to find the cache database

```
load_cache(label, object, notfound = "NOT AVAILABLE", 
  path = opts_chunk$get("cache.path"), lazy = TRUE)
```

Therefore, if you use *z* in an inline R expression, it will output `NOT AVAILABLE` and since you have specified `notfound = "NOT AVAILALBE"` it will go back at the end and replace it with the value of *z*.  

So cool!


## Side Effects

A **side effect** refers to a state change that occurs outside of a function that is not the reutrned value.  

- `par()` and `options()` are side effects in the sense that they are not cached.  
- Set all the global options in the first chunk and **never** cache that chunk.  




We need to be careful with the chunk options to be sure that results from cached chunks are up-to-date.

We can also turn off lazy-loading by setting the `cache.lazy = FALSE`. 


# Session Info 
```{r session-info, results ='markup'}
devtools::session_info()
```

